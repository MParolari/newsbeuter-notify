#!/usr/bin/env perl
#    */
#    Copyright 2010 Mikael Fridh
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# */

use strict;
use warnings;

use DBI qw(:sql_types);

# defaults
my $global_limit = 5; # limit the number of new articles to be reported. Set to 0 to notify all new articles.
my $post_max_length = 100; # limit the length of each title to be reported. Set to 0 for no limit.
my $expire_time = 5000; # millisecond
my $time_foreach_notification = 0; # if true, expire_time *= number_of_notifications
my $one_notification = 1; # if true, show only one notification for all new articles
my $notify_format = "%d new articles (%d unread, %d unread feeds)";
my $post_format = "<b>%ftitle</b>: %title";
my $cache_file = $ENV{HOME} . "/.newsbeuter/cache.db";
my $urls_file = $ENV{HOME} . "/.newsbeuter/urls";
my $icon_path = $ENV{HOME} . "/.newsbeuter/icon.png";

# variables
my $new_articles = 0;
my $unread_articles = 0;
my $unread_feeds = 0;
my $posts;

if (defined ($ARGV[0])) {
    ($new_articles, $unread_articles, $unread_feeds) = split(/\s+/, $ARGV[0]);
} else {
  warn "argv[0] not defined";
  exit(1);
}

if ($new_articles == 0) {
    if ($unread_articles+$unread_feeds == 0) {
        # All values are zero, notification pointless
        exit(0);
    } else {
        $posts = [sprintf($notify_format, $new_articles, $unread_articles,
                          $unread_feeds)];
    }
} elsif ($new_articles > 0) {
    $posts = newsbeuter_cache_fetch($new_articles);
}

if ($one_notification) {
  $expire_time *= scalar(@$posts) if ($time_foreach_notification);
  system("notify-send", "-i" => $icon_path, "-t" => $expire_time,
    "newsbeuter", join("\n", @$posts));
} else {
  foreach (@$posts) {
      system("notify-send", "-i" => $icon_path, "-t" => $expire_time,
        "newsbeuter", $_);
  }
}
exit(0);

sub newsbeuter_cache_fetch {
    my $limit = shift;
    my $more = 0;

    if($global_limit)
    {
        if ($limit > $global_limit) {
            $more = $limit - $global_limit;
            $limit = $global_limit;
        }
    }

    my $dbh = DBI->connect("dbi:SQLite:dbname=$cache_file","","");
    my $sth = $dbh->prepare("select i.id, i.title, i.author, i.url, \
                            f.title as ftitle, f.rssurl as furl \
                            from rss_item as i \
                            join rss_feed as f \
                            on (i.feedurl = f.rssurl)
                            where i.unread=1 \
                            order by i.pubDate desc limit ?");
    $sth->bind_param(1, $limit, SQL_INTEGER);
    $sth->execute();

    my @posts;
    # id, author, url is unused, but I keep it here for reference.
    # Extending or changing the output format is easy.
    while (my $hashref = $sth->fetchrow_hashref) {
        my $post = $post_format;
        my $post_length = length($post =~ s/(?:<\/?[^<>]*>)|(?:\%\w*)//gri);
        # we match format specifiers
        while ( $post =~ m/^[^%]*\%(\w*)/ ) {
          my $value = %$hashref{$1} || '';  # get value (if undef, '' is set)
          if ( $1 eq 'ftitle' ) { # get 'ftitle' defined in urls file
            my $furl = %$hashref{'furl'};
            $value = ftitle_fetch($furl) || $value ;
          }
          # we erase the value if there isn't more space
          $value = '' if ($post_length < 0) && ($post_max_length > 0);
          # if we exceed the length limit (if exists)
          if ( $post_length >= 0 && $post_max_length > 0 &&
               $post_length + length($value) > $post_max_length ) {
            # if possible, the value will be truncated
            if ( $post_max_length-$post_length-3 > 0 ) {
              $value = substr($value, 0, $post_max_length-$post_length-3);
              $value =~ s/(\s)+(\S)*$//;
              $value = $value . "...";
            } else {
              $value = ''; # if we can't truncate the value, we erase it.
            }
            # we set a negative post_length, which means there isn't more space
            $post_length = -length($value) -1;
          }
          $post_length += length($value); # update length
          $value = escape($value);        # escape special characters
          $post =~ s/%$1/$value/;         # substitution ($1 is the specifier)
        }
        push(@posts, $post);
    }

    if ($more) {
        push(@posts, sprintf("... %d more articles", $more));
    }

    $sth->finish();
    $dbh->disconnect();

    return \@posts;
}

sub escape {
  my $str = shift;
  $str =~ s/&/&amp;/g;
  $str =~ s/</&lt;/g;
  $str =~ s/>/&gt;/g;
  return $str;
}

sub ftitle_fetch {
  my $furl = shift || return '';
  open(my $file, '<', $urls_file) #TODO? :encoding(UTF-8)
    or (warn "Could not open file '$urls_file'" and return '');
  while ( my $line = <$file> ) {
    if ( $line =~ m/$furl.*"~([\w\s]+)"/ ) {
      return $1;
    }
  }
  return '';
}

=head1 NAME

newsbeuter-notify - Newsbeuter Notify

=head1 SYNOPSIS

=over 4

=item * Copy this script to F<~/.newsbeuter/newsbeuter-notify>.

=item * Add the following to your F<~/.newsbeuter/config>:

    notify-format "%d %n %f"
    notify-program "~/.newsbeuter/newsbeuter-notify"

=back

=head1 REQUIREMENTS

This version of newsbeuter-notify requires B<libnotify-bin>, B<libdbd-sqlite3-perl>

=head1 BUGS

None if set up correctly ;-).

=head1 TODO

Make it more generic, support more notification frameworks.

=head1 AUTHOR

Mikael Fridh 

=cut

